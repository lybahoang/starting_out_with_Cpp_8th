Linked list: set of data structures 'I know the guy after me'
The first byte of the next node.

A node contains TWO parts:
    1. data: one ore more data fields.
    2. pointer: the address of the next node.

Although linked list is slow to traverse, but we can have a big liked list,
because each not can be scattered around. (> array).
Advantages:
    + can be expandable (>< array).
    + easy to insert a node in between. 
    (1. Insert the newNode first, then point the previous one to newNode).


Linked list organization: 
    1. A head to point to the first node.
    2. Nodes (last node points to NULL).

Empty linked lists: The head points to NULL.

1. Initialize a linked list.
struct ListNode
{
    int data;
    ListNode *next;
}

// New linked list named numberList.
ListNode *numberList = nullptr;   // List head.

// theList is the address of the linked list (= head).
void addNode(ListNode* theList, int data)   // Add at the end of the list.
{
    // Allocate a new node and store data there, and make it point to NULL.
    ListNode *newNode = new ListNode;
    newNode->data = data;
    newNode->next = nullptr;

    // Travel to the end of the list.
    ListNode *nodePtr;      // To travel the list.

    // Position the nodePtr to the head of the list.
    nodePtr = theList;

    // While the nodePtr is not null, then skip it.
    while (nodePtr->next != nullptr)    // Or while(nodePtr->next)
    {
        // Move to the next node.
        nodePtr = nodePtr->next;
    }

    // Make the last node point to the new node.
    nodePtr->next = newNode;
}

void pushFrontNode(ListNode* theList, int data)
{
    // My method:
    // Allocate a new node and store data there.
    ListNode *newNode = new ListNode;
    newNode->data = data;

    // Make newNode point to the first node.
    newNode->next = theList->next;

    // Point the head to the new node.
    theList = newNode;

    // Teacher's Method:
    if (theList->next == nullptr)
    {
        theList->next = newNode;
    }
    else
    {
        newNode->next = theList->next;
        theList->next = newNode;
    }
}

void deleteLastNode(ListNode *theList)
{
    ListNode *previousNode;
    ListNode *nodePtr;

    nodePtr = theList;
    previousNode = nullptr;

    
}


class ListNode
{
    public:
        int data;
        ListNode* next;
    ~ListNode()
    {
        if (next)
            next = NULL;
    }
}

Delete a node.
    Step 1: Create two ListNode variables (nodePtr, previousNode).
    Step 2: If the list is empty, do nothing.
    Step 3: If the first node is the one to delete, then
        Step 3.1: 
Destroy a linked list.
    Step 1: Create two ListNode variables (nodePtr, nextNode)
    Step 2: Position nodePtr to the head of the list.
    Step 3: While nodePtr is not at the end,
        Step 3.1: Save nodePtr->next to nextNode.
        Step 3.2: Delete nodePtr.
        Step 3.3: Position nodePtr to nextNode.
        Step 3.4: Go back to step 3.


Doubly-linked list:
struct doublyListNode
{
    int data;
    doublyListNode *previous;
    doublyListNode *next;
};

doublyListNode *numberList = new doublyListNode;   // The head list.
numberList->data = 0;
numberList->previous = nullptr;
numberList->next = nullptr;

void appendNode(doublyListNode *theList, int data)
{
    doublyListNode *nodePtr;    // To traverse the list.

    // Allocate a new node and store data there.
    doublyListNode *newNode = new doublyListNode;
    newNode->data = data;
    newNode->next = nullptr;
    newNode->previous = nullptr;

    // If there are no nodes in the list, then
    // make newNode the first node.
    if (theList->next == nullptr)
    {
        theList->next = newNode;
        newNode->previous = theList;
    }
    else
    {
        // Position nodePtr at the head of the list.
        nodePtr = theList;

        // Search for the last node in the list.
        while (nodePtr->next != nullptr)
        {
            nodePtr = nodePtr->next;
        }

        // Append newNode.
        nodePtr->next = newNode;
        newNode->previous = nodePtr;
    }
}


